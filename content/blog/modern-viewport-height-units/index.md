---
title: 现代视窗高度单位的小秘密
date: 2025-11-24 14:17:50
tags:
  - CSS
  - 前端
  - AGC
---

多年前我们写移动端页面时几乎只认 `vh`，结果一到 iOS Safari 就被地址栏、工具栏打回原形：设计稿想要 100% 高度，浏览器却偏偏把一截内容挡住。最近在梳理项目的欢迎页体验时，我重新评估了视窗高度单位的组合方式，顺手整理成这篇笔记，分享我在多个项目中踩坑、复现和验证过的实践。

## 传统 vh：移动端的陷阱

`100vh` 等于布局视窗高度的 100%。在桌面端，它通常与浏览器窗口高度一致；但在 iOS Safari 上，地址栏/工具栏的占位会被忽略，所以看似“铺满”的内容仍会被系统 UI 遮挡，还会多出一截滚动条。

- 典型场景：登录页、首屏 Banner、视频落地页。设计要求看起来“全屏”，但在 iPhone、iPad Safari 中却出现滚动条或按钮被压在底部栏后。
- 复现方法：在模拟器或真机打开页面，保持地址栏展开状态并下拉刷新，即可看到 `100vh` 高度大于实际可视区域。

为了避免误导，我现在很少只写一个 `min-height: 100vh;`。在旧项目遇到滚动条问题时，先找到所有使用 `vh` 的模块，用真实设备比对，通常能快速定位问题。

## svh（small viewport height）：保守但稳定

`svh` 表示“最小可见视窗高度”，即浏览器 UI 完全展开时剩余的那块空间。它会主动把地址栏、工具栏的高度扣掉，因此得到的是**最保守**的高度。

- 适用场景：欢迎页、登录页、全屏背景图、表单等静态布局。哪怕地址栏始终不收起，也能保证主要内容完整出现。
- 我在一次活动页重构中，把根容器改成 `min-height: 100svh;`，随即解决了 iPhone X 上底部 CTA 被遮挡的问题，且不会影响 Android Chrome。

```css
.hero {
  min-height: 100svh;
  display: flex;
  align-items: center;
  justify-content: center;
  background: radial-gradient(circle, #1f2937, #0f172a);
}
```

缺点也明显：当用户上滑收起地址栏后，可视区域变大，但 `svh` 仍保持原值，于是底部会留下空白。不过比起“内容被挡”，多数业务更能接受“略微留白”。

## dvh（dynamic viewport height）：实时响应

`dvh` 表示“动态视窗高度”，会随浏览器 UI 的伸缩而实时更新。例如在 iOS Safari 中向上滚动收起地址栏，`dvh` 就会增大；反向操作时则缩小。

- 适用场景：PWA、沉浸式阅读、全屏播放器或带有交互过渡的体验。需要让布局跟随系统 UI 变化时，它就是最佳拍档。
- 在一个渐进式应用里，我使用 `min-height: 100dvh;` 配合 CSS 过渡和少量 JavaScript（监听 `resize` 事件），实现了顶部导航自动收起时的平滑伸缩，视觉上更接近原生应用。

`dvh` 的坑在于：部分旧版浏览器尚未实现它，而且过于灵敏——频繁伸缩可能触发布局抖动。因此在引用它之前，我会确认页面元素有足够的缓冲（如 `transition` 或 `clamp`）以避免闪烁。

## 组合建议：兼顾兼容性与体验

如果目标只是“至少铺满视觉区域并避免 iOS 多余滚动”，我现在默认写成：

```css
.page {
  min-height: 100vh;
  min-height: 100svh;
  min-height: 100dvh;
}
```

浏览器会自上而下选择能识别的单位：老旧浏览器只认 `vh`，新版 Safari 会优先 `svh`/`dvh`，做到兼容与体验的平衡。

- 登录/宣传页等静态模块：`svh` 带来的保守高度最稳妥，保证按钮、免责声明等内容不会再被遮挡。
- 沉浸式交互或“滑动隐藏顶部导航”类场景：优先用 `dvh`，并考虑过渡动画或 JS 监听，来获得跟随 UI 变化的全屏效果。

我的经验是：先根据业务确定“稳妥”还是“灵活”优先，再组合不同单位。理解这些“新一代视窗单位”后，移动端布局就能更精准，iOS Safari 的滚动坑也会随之淡出。
